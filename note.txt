# Http建立连接的步骤

1. 建立TCP连接
在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，
该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。
HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，
因此，首先要建立TCP连接，一般TCP连接的端口号是80。

2. Web浏览器向Web服务器发送请求命令
一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。

3. Web浏览器发送请求头信息
浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送

4. Web服务器应答
客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。

5. Web服务器发送应答头信息
正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。

6. Web服务器向浏览器发送数据
Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，
它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。

7. Web服务器关闭TCP连接
一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：
Connection:keep-alive
TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。
保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

#####################################################################################################################

# Http的请求过程

我们在浏览器输入http://www.baidu.com想要进入百度首页，但是这是个域名，没法准确定位到服务器的位置，
所以需要通过域名解析，把域名解析成对应的ip地址，然后通过ip地址查找目的主机。整个访问过程可以概括为：

域名解析
发起TCP三次握手建立连接
建立连接后发起http请求
服务器响应请求，浏览器获取html源码
浏览器解析html代码，并请求相关css,js和图片资源
浏览器渲染页面

在浏览器输入一串域名要访问某网站的时候，浏览器帮我们做了如下事情（以Chrome浏览器和windows系统为例）：

Chrome浏览器首先检查自己本地是缓存是否有对应的域名，有则直接使用。【查看Chrome浏览器dns缓存地址：chrome://net-internals/#dns】
如果浏览器缓存中没有，则查询系统DNS缓存中的域名表，有则直接使用。【windows查看域名表的命令：ipconfig /displaydns】
系统缓存中还是没有，则检查hosts文件中的映射表。【windows中hosts文件路径：C:\Windows\System32\drivers\etc】
本地实在找不到，则向DNS域名服务器发起请求查询。【DNS服务器IP是本地配置的首选服务器，一般常用的有114.114.114.114（电信运营商提供）和8.8.8.8（Google提供）】
    DNS服务器首先查找自身的缓存，有对应的域名ip则返回结果
    如果缓存中查找不到，DNS服务器则发起迭代DNS请求，首先向根域服务器发起请求查询，假如本次请求的是www.baidu.com,根域服务器发现这是一个com的顶级域名，就把com域的ip地址返回给DNS服务器
    DNS服务器向com域ip地址发起请求，查询该域名的ip，此时该服务器返回了baidu.com的DNS地址。
    最后DNS服务器又向baidu.com的DNS地址发起查询请求，最后找到了完整的ip路径返回给DNS服务器，DNS再把ip信息返回给windows内核，内核再返回给浏览器，于是浏览器就知道该域名对应的ip地址了，可以开始进一步请求了。

每个域名用小数点分隔开变成多级，从右到左等级逐级递减，所以最右边的等级最高，每个域都有用一个域名服务器，管理则下属域名

建立TCP连接

第一次握手：客户端向服务器发送SYN报文，并发送客户端初始序列号Seq=X；等待服务器确认，

第二次握手：服务器接收客户端的SYN报文，然后向客户端返回一个包SYN+ACK响应报文，并发送初始序列号Seq=Y

第三次握手：客户端接受SYN+ACK报文，并向服务器发送一个ACK确认报文，至此连接建立

【建立连接的最重要目是让连接的双方交换初始序号(ISN, Initial Sequence Number)，所以再响应的ACK报文中会包含序列号递增序列】

#####################################################################################################################

# send、recv等socket编程接口的阻塞与非阻塞模式

socket编程中经常使用send和recv函数来接收和发送数据。
对于系统来说，不管是发送数据还是接收数据，都不是直接在内存上操作的。 发送数据有发送缓冲区，接收数据有接收缓冲区。

对于send来说，send函数调用时，先将将应用程序请求发送的数据拷贝到发送缓存中，而后驱动程序会去读取发送缓冲中的数据，在进行真正的传输。
对于recv来说，recv只是从接收缓冲中读取数据，而接收缓存中的数据来自于网卡驱动。

既然调用send和recv时，是与缓冲区进行交互，那么就至少可能存在以下问题：
1. 对send来说， 发送缓冲区的可用空间不足以拷贝要发送的数据怎么办，是阻塞等待、还是返回失败信息？
2. 对recv来说，接收缓冲区还没有数据可读怎么办， 是阻塞等到有数据，还是返回失败？

阻塞 与 非阻塞
在阻塞模式下，send调用在发送缓冲区可用空间不足时，会阻塞等待； recv调用在接收缓冲区还没有数据可读时，也会阻塞等待。
在非阻塞模式下，send调用在发送缓冲区可用空间不足时，会返回失败； recv调用在接收缓冲区还没有数据可读时，也会返回失败。

默认情况下，send、recv等socket编程接口工作在阻塞模式下。
也就是说，当程序执行到recv时，如果对方数据还没发出来、或者说还没到达我们的接收缓冲区，程序就阻塞在recv了。
